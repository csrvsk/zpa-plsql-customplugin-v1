package com.company.plsql;

import org.sonar.plugins.plsqlopen.api.DdlGrammar;
import org.sonar.plugins.plsqlopen.api.annotations.Priority;
import org.sonar.plugins.plsqlopen.api.annotations.Rule;
import org.sonar.plugins.plsqlopen.api.annotations.ActivatedByDefault;
import org.sonar.plugins.plsqlopen.api.annotations.ConstantRemediation;
import org.sonar.plugins.plsqlopen.api.checks.PlSqlCheck;
import org.sonar.plugins.plsqlopen.api.sslr.AstNode;

import org.junit.Test;
import org.sonar.plugins.plsqlopen.api.checks.Check;
import org.sonar.plugins.plsqlopen.checks.verifier.PlSqlCheckVerifier;

import java.util.regex.Pattern;
import java.util.logging.Logger;

@Rule(
    name = "Table Naming Conventions",
    description = "Ensure tables follow the defined naming conventions.",
    key = "TableNamingCheck",
    priority = Priority.MAJOR
)
@ConstantRemediation("10min")
@ActivatedByDefault
public class TableNamingCheck extends PlSqlCheck {

    private final static Logger LOGGER = Logger.getLogger(TableNamingCheck.class.getName());

    private static final Pattern TABLE_PATTERN = Pattern.compile("^([A-Z0-9]{2,3})_([A-Z0-9_]+)(_TN|_TABLE_TN|_TABLE)?$");

    @Override
    public void init() {
        subscribeTo(DdlGrammar.CREATE_TABLE);
    }

    @Override
    public void visitNode(AstNode node) {
        // Check for a CREATE_TABLE child node
        if (node.hasDirectChildren(DdlGrammar.CREATE_TABLE)) {
            AstNode createTableNode = node.getFirstChild(DdlGrammar.CREATE_TABLE);
            String tableName = createTableNode.getTokenOriginalValue().toUpperCase();
            LOGGER.info("Evaluating table name: " + tableName);

            if (!TABLE_PATTERN.matcher(tableName).matches()) {
                addIssue(node, "Table name does not follow the naming conventions.");
            }
        }
    }
}
